unit HTL_CTabBar;

interface

uses
  System.SysUtils, System.Classes, System.Generics.Collections, System.Types,
  Vcl.Controls, Vcl.Graphics, Vcl.ExtCtrls,
  Winapi.Windows, Winapi.Messages, System.UITypes,
  Winapi.GDIPOBJ, Winapi.GDIPAPI,
  HTL_ComponentUtils;

type
  TTabBarStyle = (
    tsContained, tsPill, tsUnderlined, tsGradientUnderlined,
    tsDottedIndicator, tsSegmented, tsBordered, tsDualLine, tsSideLines
  );

  THTL_CTabBar = class;

  THTL_CTabItem = class(TCollectionItem)
  private
    FCaption: string;
    FVisible: Boolean;
    FEnabled: Boolean;
    FTag: Integer;
    FWidth: Integer;
    procedure SetCaption(const Value: string);
    procedure SetVisible(const Value: Boolean);
    procedure SetEnabled(const Value: Boolean);
    procedure SetWidth(const Value: Integer);
  protected
    function GetDisplayName: string; override;
  public
    constructor Create(Collection: TCollection); override;
  published
    property Caption: string read FCaption write SetCaption;
    property Width: Integer read FWidth write SetWidth default 80;
    property Visible: Boolean read FVisible write SetVisible default True;
    property Enabled: Boolean read FEnabled write SetEnabled default True;
    property Tag: Integer read FTag write FTag default 0;
  end;

  THTL_CTabItems = class(TCollection)
  private
    FOwner: THTL_CTabBar;
    function GetItem(Index: Integer): THTL_CTabItem;
    procedure SetItem(Index: Integer; const Value: THTL_CTabItem);
  protected
    function GetOwner: TPersistent; override;
    procedure Update(Item: TCollectionItem); override;
  public
    constructor Create(AOwner: THTL_CTabBar);
    function Add: THTL_CTabItem;
    property Items[Index: Integer]: THTL_CTabItem read GetItem write SetItem; default;
  end;

  THTL_CTabBar = class(TCustomControl)
  private
    FItems: THTL_CTabItems;
    FContainer: TBorderSettings;
    FStyle: TTabBarStyle;
    FSpacing: Integer;
    FAutoSizeTabs: Boolean;
    FActiveIndex: Integer;
    FActiveIndicator: TBorderSettings;
    FGradient: TGradientSettings;
    FActiveFontColor: TColor;
    FInactiveFontColor: TColor;
    FHoverSettings: THoverSettings;
    FOnChange: TNotifyEvent;

    FAnimationTimer: TTimer;
    FActiveIndicatorAnimProgress: Single;
    FHoveredTabIndex: Integer;
    FPreviousHoveredTabIndex: Integer;
    FHoverAnimProgress: Single;
    FFromRect: TRect;
    FToRect: TRect;

    procedure SetItems(const Value: THTL_CTabItems);
    procedure SetContainer(const Value: TBorderSettings);
    procedure SetStyle(const Value: TTabBarStyle);
    procedure SetSpacing(const Value: Integer);
    procedure SetAutoSizeTabs(const Value: Boolean);
    procedure SetActiveIndex(const Value: Integer);
    procedure SetActiveIndicator(const Value: TBorderSettings);
    procedure SetGradient(const Value: TGradientSettings);
    procedure SetActiveFontColor(const Value: TColor);
    procedure SetInactiveFontColor(const Value: TColor);
    procedure SetHoverSettings(const Value: THoverSettings);
    procedure Animate(Sender: TObject);
    procedure SettingsChanged(Sender: TObject);
    procedure UpdateLayout;
    procedure ApplyStyleDefaults;
    function GetItemAt(X, Y: Integer): Integer;
    function GetItemRect(Index: Integer): TRect;

  protected
    procedure Paint; override;
    procedure Loaded; override;
    procedure Resize; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
    procedure MouseMove(Shift: TShiftState; X, Y: Integer); override;
    procedure CMMouseLeave(var Message: TMessage); message CM_MOUSELEAVE;

  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

  published
    property Items: THTL_CTabItems read FItems write SetItems;
    property ActiveIndex: Integer read FActiveIndex write SetActiveIndex default -1;
    property Style: TTabBarStyle read FStyle write SetStyle default tsContained;
    property Spacing: Integer read FSpacing write SetSpacing default 0;
    property AutoSizeTabs: Boolean read FAutoSizeTabs write SetAutoSizeTabs default True;
    property Container: TBorderSettings read FContainer write SetContainer;
    property ActiveIndicator: TBorderSettings read FActiveIndicator write SetActiveIndicator;
    property Gradient: TGradientSettings read FGradient write SetGradient;
    property ActiveFontColor: TColor read FActiveFontColor write SetActiveFontColor default clBlack;
    property InactiveFontColor: TColor read FInactiveFontColor write SetInactiveFontColor default TColor($00666666);
    property HoverSettings: THoverSettings read FHoverSettings write SetHoverSettings;
    property Align;
    property Anchors;
    property Constraints;
    property Enabled;
    property Font;
    property ParentShowHint;
    property PopupMenu;
    property ShowHint;
    property TabOrder;
    property TabStop default True;
    property Visible;
    property OnClick;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
    property OnMouseDown;
    property OnMouseMove;
    property OnMouseUp;
  end;

procedure Register;

implementation

uses System.Math;

procedure Register;
begin
  RegisterComponents('HOTLINE', [THTL_CTabBar]);
end;

{ THTL_CTabItem }
constructor THTL_CTabItem.Create(Collection: TCollection); begin inherited Create(Collection); FVisible := True; FEnabled := True; FWidth := 80; FCaption := 'Tab ' + IntToStr(Collection.Count); end;
function THTL_CTabItem.GetDisplayName: string; begin if FCaption <> '' then Result := FCaption else Result := inherited GetDisplayName; end;
procedure THTL_CTabItem.SetCaption(const Value: string); begin if FCaption <> Value then begin FCaption := Value; Changed(False); end; end;
procedure THTL_CTabItem.SetVisible(const Value: Boolean); begin if FVisible <> Value then begin FVisible := Value; Changed(False); end; end;
procedure THTL_CTabItem.SetEnabled(const Value: Boolean); begin if FEnabled <> Value then begin FEnabled := Value; Changed(False); end; end;
procedure THTL_CTabItem.SetWidth(const Value: Integer); begin if FWidth <> Value then begin FWidth := Value; Changed(False); end; end;

{ THTL_CTabItems }
constructor THTL_CTabItems.Create(AOwner: THTL_CTabBar); begin inherited Create(THTL_CTabItem); FOwner := AOwner; end;
function THTL_CTabItems.Add: THTL_CTabItem; begin Result := THTL_CTabItem(inherited Add); end;
function THTL_CTabItems.GetItem(Index: Integer): THTL_CTabItem; begin Result := THTL_CTabItem(inherited GetItem(Index)); end;
function THTL_CTabItems.GetOwner: TPersistent; begin Result := FOwner; end;
procedure THTL_CTabItems.SetItem(Index: Integer; const Value: THTL_CTabItem); begin inherited SetItem(Index, Value); end;
procedure THTL_CTabItems.Update(Item: TCollectionItem); begin inherited; if Assigned(FOwner) and not (csLoading in FOwner.ComponentState) then FOwner.UpdateLayout; end;

{ THTL_CTabBar }
constructor THTL_CTabBar.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  ControlStyle := [csOpaque, csReplicatable, csDoubleClicks, csCaptureMouse, csSetCaption, csAcceptsControls];
  DoubleBuffered := True;
  Width := 250;
  Height := 40;
  TabStop := True;
  Font.Name := 'Segoe UI';
  Font.Size := 10;
  FItems := THTL_CTabItems.Create(Self);
  FContainer := TBorderSettings.Create;
  FContainer.OnChange := SettingsChanged;
  FContainer.BackgroundColor := TColor($00F2F2F2);
  FContainer.Color := TColor($00CCCCCC);
  FContainer.Thickness := 1;
  FContainer.CornerRadius := 8;
  FActiveIndicator := TBorderSettings.Create;
  FActiveIndicator.OnChange := SettingsChanged;
  FActiveIndicator.BackgroundColor := clWhite;
  FActiveIndicator.Color := clHighlight;
  FActiveIndicator.Thickness := 2;
  FActiveIndicator.CornerRadius := 6;
  FGradient := TGradientSettings.Create;
  FGradient.OnChange := SettingsChanged;
  FGradient.Enabled := False;
  FGradient.StartColor := TColor($00FF8C00);
  FGradient.EndColor := TColor($004169E1);
  FHoverSettings := THoverSettings.Create(Self);
  FHoverSettings.OnChange := SettingsChanged;
  FHoverSettings.OnAnimationProgress := SettingsChanged;
  // CORREÇÃO: Usar uma cor padrão visível para o fundo do hover
  FHoverSettings.BackgroundColor := TColor($FFE0E8F0); // Um azul-acinzentado claro
  FHoverSettings.BorderColor := clHighlight;
  FHoverSettings.FontColor := clHighlight;
  FHoverSettings.HoverEffect := heFade;
  FStyle := tsContained;
  FSpacing := 0;
  FAutoSizeTabs := True;
  FActiveIndex := -1;
  FActiveFontColor := clBlack;
  FInactiveFontColor := TColor($00666666);
  FHoveredTabIndex := -1;
  FPreviousHoveredTabIndex := -1;
  FActiveIndicatorAnimProgress := 1.0;
  FHoverAnimProgress := 0.0;
  FAnimationTimer := TTimer.Create(Self);
  FAnimationTimer.Enabled := False;
  FAnimationTimer.Interval := 15;
  FAnimationTimer.OnTimer := Animate;
  ApplyStyleDefaults;
end;

destructor THTL_CTabBar.Destroy; begin FItems.Free; FContainer.Free; FActiveIndicator.Free; FGradient.Free; FHoverSettings.Free; FAnimationTimer.Free; inherited Destroy; end;
procedure THTL_CTabBar.Loaded; begin inherited; if (FActiveIndex >= 0) and (FActiveIndex < FItems.Count) then begin FToRect := GetItemRect(FActiveIndex); FFromRect := FToRect; FActiveIndicatorAnimProgress := 1.0; end; UpdateLayout; end;
procedure THTL_CTabBar.Resize; begin inherited; UpdateLayout; end;
procedure THTL_CTabBar.SettingsChanged(Sender: TObject); begin Invalidate; end;
procedure THTL_CTabBar.UpdateLayout; begin Invalidate; end;
procedure THTL_CTabBar.Animate(Sender: TObject); var NeedsAnimation: Boolean; AnimationStep: Single; begin NeedsAnimation := False; if FActiveIndicatorAnimProgress < 1.0 then begin FActiveIndicatorAnimProgress := Min(1.0, FActiveIndicatorAnimProgress + 0.15); NeedsAnimation := True; end; if FHoverAnimProgress < 1.0 then begin AnimationStep := FAnimationTimer.Interval / Max(1, FHoverSettings.AnimationTimerInterval * 5); FHoverAnimProgress := Min(1.0, FHoverAnimProgress + AnimationStep); NeedsAnimation := True; end; FAnimationTimer.Enabled := NeedsAnimation; Invalidate; end;
function THTL_CTabBar.GetItemAt(X, Y: Integer): Integer; var i: Integer; begin for i := 0 to FItems.Count - 1 do if FItems[i].Visible and PtInRect(GetItemRect(i), Point(X, Y)) then Exit(i); Result := -1; end;
procedure THTL_CTabBar.CMMouseLeave(var Message: TMessage); begin inherited; Self.Cursor := crDefault; if FHoveredTabIndex <> -1 then begin FPreviousHoveredTabIndex := FHoveredTabIndex; FHoveredTabIndex := -1; FHoverAnimProgress := 0.0; FAnimationTimer.Enabled := True; end; end;
procedure THTL_CTabBar.MouseMove(Shift: TShiftState; X, Y: Integer); var NewHoverIndex: Integer; begin inherited; if not Enabled then begin Self.Cursor := crDefault; Exit; end; NewHoverIndex := GetItemAt(X, Y); if (NewHoverIndex <> -1) and FItems[NewHoverIndex].Enabled then Self.Cursor := crHandPoint else Self.Cursor := crDefault; if NewHoverIndex <> FHoveredTabIndex then begin FPreviousHoveredTabIndex := FHoveredTabIndex; FHoveredTabIndex := NewHoverIndex; FHoverAnimProgress := 0.0; FAnimationTimer.Enabled := True; end; end;
procedure THTL_CTabBar.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); var ItemIndex: Integer; begin inherited; if Button = mbLeft then begin ItemIndex := GetItemAt(X, Y); if (ItemIndex <> -1) and FItems[ItemIndex].Enabled then Self.ActiveIndex := ItemIndex; end; end;
procedure THTL_CTabBar.SetActiveIndex(const Value: Integer); var PrevIndex: Integer; begin PrevIndex := FActiveIndex; if (Value >= -1) and (Value < FItems.Count) and (FActiveIndex <> Value) then begin FActiveIndex := Value; if (PrevIndex > -1) and (PrevIndex < FItems.Count) then FFromRect := GetItemRect(PrevIndex) else if FItems.Count > 0 then FFromRect := GetItemRect(IfThen(Value > -1, Value, 0)); if (FActiveIndex > -1) then FToRect := GetItemRect(FActiveIndex) else FToRect := FFromRect; FActiveIndicatorAnimProgress := 0.0; FAnimationTimer.Enabled := True; if Assigned(FOnChange) then FOnChange(Self); Invalidate; end; end;
procedure THTL_CTabBar.SetItems(const Value: THTL_CTabItems); begin FItems.Assign(Value); UpdateLayout; Invalidate; end;
procedure THTL_CTabBar.SetContainer(const Value: TBorderSettings); begin FContainer.Assign(Value); Invalidate; end;
procedure THTL_CTabBar.SetSpacing(const Value: Integer); begin if FSpacing <> Value then begin FSpacing := Value; UpdateLayout; Invalidate; end; end;
procedure THTL_CTabBar.SetActiveIndicator(const Value: TBorderSettings); begin FActiveIndicator.Assign(Value); Invalidate; end;
procedure THTL_CTabBar.SetActiveFontColor(const Value: TColor); begin if FActiveFontColor <> Value then begin FActiveFontColor := Value; Invalidate; end; end;
procedure THTL_CTabBar.SetInactiveFontColor(const Value: TColor); begin if FInactiveFontColor <> Value then begin FInactiveFontColor := Value; Invalidate; end; end;
procedure THTL_CTabBar.SetHoverSettings(const Value: THoverSettings); begin FHoverSettings.Assign(Value); Invalidate; end;
procedure THTL_CTabBar.SetGradient(const Value: TGradientSettings); begin FGradient.Assign(Value); Invalidate; end;
procedure THTL_CTabBar.SetAutoSizeTabs(const Value: Boolean); begin if FAutoSizeTabs <> Value then begin FAutoSizeTabs := Value; UpdateLayout; Invalidate; end; end;

procedure THTL_CTabBar.ApplyStyleDefaults;
begin
  case FStyle of
    tsContained, tsPill, tsSegmented:
      FHoverSettings.Targets := [htBackground, htFont];
    tsUnderlined, tsGradientUnderlined, tsDottedIndicator,
    tsDualLine, tsSideLines, tsBordered:
      FHoverSettings.Targets := [htFont, htIndicator];
  else
    FHoverSettings.Targets := [htBackground, htFont, htBorder];
  end;
end;

procedure THTL_CTabBar.SetStyle(const Value: TTabBarStyle);
begin
  if FStyle <> Value then
  begin
    FStyle := Value;
    ApplyStyleDefaults;
    FActiveIndicatorAnimProgress := 1.0;
    if (FActiveIndex >= 0) and (FActiveIndex < FItems.Count) then
    begin
      FToRect := GetItemRect(FActiveIndex);
      FFromRect := FToRect;
    end;
    if FStyle = tsGradientUnderlined then
      FGradient.Enabled := True
    else
      FGradient.Enabled := False;
    Invalidate;
  end;
end;

function THTL_CTabBar.GetItemRect(Index: Integer): TRect;
var i, VisibleItemIndex, VisibleCount: Integer; ContentWidth, ContentHeight, TotalSpacing, TotalManualWidth: Integer; VisibleItemsWidths: TList<Integer>; CurrentX: Integer;
begin
  Result := Rect(0,0,0,0); if (Index < 0) or (Index >= FItems.Count) then Exit;
  VisibleItemsWidths := TList<Integer>.Create;
  try
    VisibleCount := 0; for i := 0 to FItems.Count - 1 do if FItems[i].Visible then begin Inc(VisibleCount); if FAutoSizeTabs then VisibleItemsWidths.Add(1) else VisibleItemsWidths.Add(FItems[i].Width); end;
    if VisibleCount = 0 then Exit;
    ContentWidth := Self.ClientWidth - (FContainer.Thickness * 2); ContentHeight := Self.ClientHeight - (FContainer.Thickness * 2); TotalSpacing := Max(0, VisibleCount - 1) * FSpacing; CurrentX := FContainer.Thickness; VisibleItemIndex := -1;
    for i := 0 to Index do if FItems[i].Visible then Inc(VisibleItemIndex);
    if FAutoSizeTabs then begin var NetTabWidth := ContentWidth - TotalSpacing; Result.Left := FContainer.Thickness + Round(VisibleItemIndex * (NetTabWidth / VisibleCount) + (VisibleItemIndex * FSpacing)); Result.Right := FContainer.Thickness + Round((VisibleItemIndex + 1) * (NetTabWidth / VisibleCount) + (VisibleItemIndex * FSpacing)); if (VisibleItemIndex = VisibleCount - 1) then Result.Right := FContainer.Thickness + ContentWidth; end else begin TotalManualWidth := 0; for i := 0 to VisibleItemsWidths.Count - 1 do TotalManualWidth := TotalManualWidth + VisibleItemsWidths[i]; TotalManualWidth := TotalManualWidth + TotalSpacing; CurrentX := FContainer.Thickness + Max(0, (ContentWidth - TotalManualWidth) div 2); var TempVisibleIdx: Integer := -1; for i := 0 to FItems.Count - 1 do begin if FItems[i].Visible then begin Inc(TempVisibleIdx); if TempVisibleIdx = VisibleItemIndex then begin Result.Left := CurrentX; Result.Right := CurrentX + FItems[i].Width; Break; end; CurrentX := CurrentX + FItems[i].Width + FSpacing; end; end; end;
    Result.Top := FContainer.Thickness; Result.Bottom := FContainer.Thickness + ContentHeight;
  finally VisibleItemsWidths.Free; end;
end;

procedure THTL_CTabBar.Paint;
var
  LG: TGPGraphics;
  i, LastVisibleIndex: Integer;
  Item: THTL_CTabItem;
  ItemRect: TRect;
  FinalFontColor, FinalBackgroundColor, FinalIndicatorColor: TColor;
  IndicatorRect: TRect;
  IndicatorPen: TGPPen;
  IndicatorBrush: TGPBrush;
  SeparatorPen: TGPPen;
  IsItemActive, IsItemDisabled: Boolean;
  HoverOpacity: Byte;
begin
  inherited;
  LG := TGPGraphics.Create(Self.Canvas.Handle);
  try
    LG.SetSmoothingMode(SmoothingModeHighQuality);
    LG.SetInterpolationMode(InterpolationModeHighQualityBicubic);
    LG.SetPixelOffsetMode(PixelOffsetModeHalf);

    if FContainer.Visible then
      DrawEditBox(LG, ClientRect, FContainer.BackgroundColor, FContainer.Color, FContainer.Thickness, FContainer.Style, FContainer.CornerRadius, FContainer.RoundCornerType, 255);

    if (FActiveIndex >= 0) and (FActiveIndex < FItems.Count) and FItems[FActiveIndex].Visible then
    begin
      IndicatorRect.Left   := Round(FFromRect.Left + (FToRect.Left - FFromRect.Left) * FActiveIndicatorAnimProgress);
      IndicatorRect.Top    := Round(FFromRect.Top + (FToRect.Top - FFromRect.Top) * FActiveIndicatorAnimProgress);
      IndicatorRect.Right  := Round(FFromRect.Right + (FToRect.Right - FFromRect.Right) * FActiveIndicatorAnimProgress);
      IndicatorRect.Bottom := Round(FFromRect.Bottom + (FToRect.Bottom - FFromRect.Bottom) * FActiveIndicatorAnimProgress);
      InflateRect(IndicatorRect, -FSpacing, -FSpacing);

      FinalIndicatorColor := FActiveIndicator.Color;
      if (FActiveIndex = FPreviousHoveredTabIndex) and (htIndicator in FHoverSettings.Targets) then
        FinalIndicatorColor := BlendColors(FHoverSettings.BorderColor, FActiveIndicator.Color, FHoverAnimProgress)
      else if (FActiveIndex = FHoveredTabIndex) and (htIndicator in FHoverSettings.Targets) then
        FinalIndicatorColor := BlendColors(FActiveIndicator.Color, FHoverSettings.BorderColor, FHoverAnimProgress);

      case FStyle of
        tsContained: DrawEditBox(LG, IndicatorRect, FActiveIndicator.BackgroundColor, FinalIndicatorColor, FActiveIndicator.Thickness, FActiveIndicator.Style, FActiveIndicator.CornerRadius, FActiveIndicator.RoundCornerType, 255);
        tsPill: DrawEditBox(LG, IndicatorRect, FActiveIndicator.BackgroundColor, FinalIndicatorColor, FActiveIndicator.Thickness, FActiveIndicator.Style, IndicatorRect.Height div 2, rctAll, 255);
        tsUnderlined: begin IndicatorPen := TGPPen.Create(ColorToARGB(FinalIndicatorColor), FActiveIndicator.Thickness); try IndicatorPen.SetStartCap(LineCapRound); IndicatorPen.SetEndCap(LineCapRound); LG.DrawLine(IndicatorPen, IndicatorRect.Left + FActiveIndicator.CornerRadius, IndicatorRect.Bottom - (FActiveIndicator.Thickness/2), IndicatorRect.Right - FActiveIndicator.CornerRadius, IndicatorRect.Bottom - (FActiveIndicator.Thickness/2)); finally IndicatorPen.Free; end; end;
        tsGradientUnderlined: begin var GradRect: TGPRectF; GradRect.X := IndicatorRect.Left; GradRect.Y := IndicatorRect.Bottom - FActiveIndicator.Thickness; GradRect.Width := IndicatorRect.Width; GradRect.Height := FActiveIndicator.Thickness; if (GradRect.Width > 0) and (GradRect.Height > 0) and FGradient.Enabled then begin IndicatorBrush := TGPLinearGradientBrush.Create(GradRect, ColorToARGB(FGradient.StartColor), ColorToARGB(FGradient.EndColor), LinearGradientModeHorizontal); try LG.FillRectangle(IndicatorBrush, GradRect); finally IndicatorBrush.Free; end; end; end;
        tsDottedIndicator: begin var DotSize := Min(6, IndicatorRect.Height div 4); if FItems.Count > FActiveIndex then begin var TextWidth := Self.Canvas.TextWidth(FItems[FActiveIndex].Caption); var DotX := IndicatorRect.Left + (IndicatorRect.Width - TextWidth) div 2 - DotSize - 4; var DotY := IndicatorRect.Top + (IndicatorRect.Height - DotSize) div 2; IndicatorBrush := TGPSolidBrush.Create(ColorToARGB(FActiveFontColor)); try LG.FillEllipse(IndicatorBrush, DotX, DotY, DotSize, DotSize); finally IndicatorBrush.Free; end; end; end;
        tsBordered: DrawEditBox(LG, IndicatorRect, clNone, FinalIndicatorColor, FActiveIndicator.Thickness, psSolid, FActiveIndicator.CornerRadius, FActiveIndicator.RoundCornerType, 255);
        tsDualLine: begin IndicatorPen := TGPPen.Create(ColorToARGB(FinalIndicatorColor), FActiveIndicator.Thickness); try LG.DrawLine(IndicatorPen, IndicatorRect.Left, IndicatorRect.Top + 1, IndicatorRect.Right, IndicatorRect.Top + 1); LG.DrawLine(IndicatorPen, IndicatorRect.Left, IndicatorRect.Bottom - 1, IndicatorRect.Right, IndicatorRect.Bottom - 1); finally IndicatorPen.Free; end; end;
        tsSideLines: begin IndicatorPen := TGPPen.Create(ColorToARGB(FinalIndicatorColor), FActiveIndicator.Thickness); try LG.DrawLine(IndicatorPen, IndicatorRect.Left + 1, IndicatorRect.Top, IndicatorRect.Left + 1, IndicatorRect.Bottom); LG.DrawLine(IndicatorPen, IndicatorRect.Right - 1, IndicatorRect.Top, IndicatorRect.Right - 1, IndicatorRect.Bottom); finally IndicatorPen.Free; end; end;
      end;
    end;

    for i := 0 to FItems.Count - 1 do
    begin
      Item := FItems[i];
      if not Item.Visible then Continue;
      ItemRect := GetItemRect(i);
      if IsRectEmpty(ItemRect) then continue;

      IsItemActive := (i = FActiveIndex);
      IsItemDisabled := not Item.Enabled;
      FinalFontColor := FInactiveFontColor;

      // Animação de FADE OUT para a tab anterior
      if (i = FPreviousHoveredTabIndex) and (i <> FHoveredTabIndex) and not IsItemActive then
      begin
        if (htFont in FHoverSettings.Targets) then FinalFontColor := BlendColors(FHoverSettings.FontColor, FInactiveFontColor, FHoverAnimProgress);
        if (htBackground in FHoverSettings.Targets) and (FHoverSettings.BackgroundColor <> clNone) then
        begin
          HoverOpacity := Round(255 * (1 - FHoverAnimProgress));
          if HoverOpacity > 0 then
          begin
            var HoverRadius := IfThen(FStyle = tsPill, ItemRect.Height div 2, FActiveIndicator.CornerRadius);
            DrawEditBox(LG, ItemRect, FHoverSettings.BackgroundColor, clNone, 0, psClear, HoverRadius, rctAll, HoverOpacity);
          end;
        end;
      end;

      // Animação de FADE IN para a nova tab com hover
      if (i = FHoveredTabIndex) and not IsItemActive then
      begin
        if (htFont in FHoverSettings.Targets) then FinalFontColor := BlendColors(FInactiveFontColor, FHoverSettings.FontColor, FHoverAnimProgress);
        if (htBackground in FHoverSettings.Targets) and (FHoverSettings.BackgroundColor <> clNone) then
        begin
          HoverOpacity := Round(255 * FHoverAnimProgress);
          if HoverOpacity > 0 then
          begin
            var HoverRadius := IfThen(FStyle = tsPill, ItemRect.Height div 2, FActiveIndicator.CornerRadius);
            // CORREÇÃO: Usa a cor da borda do HoverSettings
            var HoverBorderColor := BlendColors(clNone, FHoverSettings.BorderColor, FHoverAnimProgress);
            var HoverBorderThickness: Integer;
            if (HoverBorderColor <> clNone) and (htBorder in FHoverSettings.Targets) then
              HoverBorderThickness := 1
            else
              HoverBorderThickness := 0;
            DrawEditBox(LG, ItemRect, FHoverSettings.BackgroundColor, HoverBorderColor, HoverBorderThickness, psSolid, HoverRadius, rctAll, HoverOpacity);
          end;
        end;
      end;

      if IsItemActive then FinalFontColor := FActiveFontColor;
      if IsItemDisabled then FinalFontColor := clGrayText;

      if (FStyle = tsSegmented) and IsItemActive then
         DrawEditBox(LG, ItemRect, FActiveIndicator.BackgroundColor, FActiveIndicator.Color, FActiveIndicator.Thickness, FActiveIndicator.Style, FActiveIndicator.CornerRadius, rctAll, 255);

      DrawComponentCaption(Self.Canvas, ItemRect, Item.Caption, Self.Font, FinalFontColor, taCenter, cvaCenter, false, 255);
    end;

    if FStyle = tsSegmented then
    begin
       LastVisibleIndex := -1;
       for i := FItems.Count - 1 downto 0 do if FItems[i].Visible then begin LastVisibleIndex := i; break; end;
       if LastVisibleIndex > 0 then
       begin
         SeparatorPen := TGPPen.Create(ColorToARGB(FContainer.Color), FContainer.Thickness);
         try
           for i := 0 to LastVisibleIndex - 1 do
             if FItems[i].Visible and (i <> FActiveIndex) and ((i + 1) <> FActiveIndex) then
               begin ItemRect := GetItemRect(i); LG.DrawLine(SeparatorPen, ItemRect.Right, ItemRect.Top + 4, ItemRect.Right, ItemRect.Bottom - 4); end;
         finally
           SeparatorPen.Free;
         end;
       end;
    end;
  finally
    LG.Free;
  end;
end;

end.
